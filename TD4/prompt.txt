projet : simulation du systeme solaire de mani√®re interactive
architecture : 
	- une page html pour heberger l'appli
	- un ou plusieurs fichiers js pour le code de l'appli
	- mod√®les 3d deja charg√©s dans ./ressources/3dmodels/<model>
		ex : modele de mercure dans ./ressources/3dmodels/mercure/, modele de venus dans ./ressources/3dmodels/venus/, etc...
#cmd
C:\Users\etudiant\Desktop\BUT3\SEM5\R506\initiation-multimedia\LABARTHE-hub.github.io\TD4>dir * /s /p
 Le volume dans le lecteur C n‚Äôa pas de nom.
 Le num√©ro de s√©rie du volume est DE5D-ACF1

 R√©pertoire de C:\Users\etudiant\Desktop\BUT3\SEM5\R506\initiation-multimedia\LABARTHE-hub.github.io\TD4

23/10/2025  10:29    <DIR>          .
23/10/2025  10:29    <DIR>          ..
23/10/2025  10:05             2¬†018 prompt.txt
23/10/2025  10:30    <DIR>          ressources
               1 fichier(s)            2¬†018 octets

 R√©pertoire de C:\Users\etudiant\Desktop\BUT3\SEM5\R506\initiation-multimedia\LABARTHE-hub.github.io\TD4\ressources

23/10/2025  10:30    <DIR>          .
23/10/2025  10:30    <DIR>          ..
23/10/2025  10:31    <DIR>          3dmodels
               0 fichier(s)                0 octets

 R√©pertoire de C:\Users\etudiant\Desktop\BUT3\SEM5\R506\initiation-multimedia\LABARTHE-hub.github.io\TD4\ressources\3dmodels

23/10/2025  10:31    <DIR>          .
23/10/2025  10:31    <DIR>          ..
23/10/2025  10:30    <DIR>          earth
23/10/2025  10:30    <DIR>          jupiter
23/10/2025  10:30    <DIR>          mars
23/10/2025  10:30    <DIR>          mercure
23/10/2025  10:31    <DIR>          neptune
23/10/2025  10:30    <DIR>          saturne
Appuyez sur une touche pour continuer...
23/10/2025  10:31    <DIR>          sun
23/10/2025  10:30    <DIR>          uranus
23/10/2025  10:30    <DIR>          venus
               0 fichier(s)                0 octets


contraintes :
	- doit fonctionn√© une fois push sur github
	- utiliser three.js pour la gestion de la 3d (pas de contrainte de librairie pour le reconaissance d'images)
	- par d√©faut, vue d'au dessus, centr√© sur soleil, vue sur tout le syst√®me
contexte :
	- simulation (simpliste) du syst√®me solaire, soleil, plan√®tes repr√©sent√©s
	- distances plan√®tes-soleil mises √† l'√©chelle
	- plan√®tes en rotation
	- temps de rotations et trajectoires respect√©s
	- √©chelles de tailles √† repsecter
	- possibilit√© d'accelerer le temps (temps de base 1sec (r√©alit√©) = 1 jour (simulation))
interactivit√© :
	l'interactivit√© se fais par reconaissance vocale, 
	si je dis le nom d'une plan√®te, la cam√©ra se centre sur celle ci et zoom dessus, 
	si je dis "syst√®me" la cam√©ra reviens sur le syst√®me solaire de base
	le zoom se fais aussi par les commandes vocales "avance" et "recule"

ici, le soleil s'affiche comme une shepre jaune, les plan√®tes ne s'affichent pas sur leur orbites, 
la console web affiche 2GLTFLoader.js:419  THREE.GLTFLoader: Unknown extension "KHR_materials_pbrSpecularGlossiness". pourtant, toutes les scenes sont au format GLTF
si je dis soleil, cela zoom su le soleil, la commande syst√®me fonctionne √† ce moment la,
si je dis le nom d'une plan√®te, cela affiche un √©cran noir
si, apr√®s √ßa, je re dis soleil, cela reste un √©cran noir, apr√®s √ßa, la commande syst√®me ne fonctionne plus



CODE A CORRIGER

HTML
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üåû Simulation du Syst√®me Solaire ‚Äî Commandes vocales</title>

  <style>
    body {
      margin: 0;
      background: #000;
      color: #eee;
      font-family: system-ui, sans-serif;
      overflow: hidden;
    }
    header, footer {
      text-align: center;
      background: #111;
      padding: 0.5em;
    }
    main {
      display: flex;
      height: calc(100vh - 100px);
    }
    #sim {
      flex: 3;
      position: relative;
    }
    #three-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    aside {
      flex: 1;
      background: #111;
      padding: 1em;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      border-left: 1px solid #333;
    }
    button {
      margin: 0.25em;
      padding: 0.5em 1em;
      border: none;
      border-radius: 0.5em;
      cursor: pointer;
      background: #333;
      color: #fff;
    }
    button:hover { background: #555; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <header><h1>üåç Simulation du Syst√®me Solaire</h1></header>

  <main>
    <section id="sim"><canvas id="three-canvas"></canvas></section>
    <aside>
      <div>
        <h2>üé§ Commandes vocales</h2>
        <p>Dites : <strong>‚ÄúSoleil‚Äù, ‚ÄúTerre‚Äù, ‚ÄúMars‚Äù, ‚ÄúSyst√®me‚Äù, ‚ÄúAvance‚Äù, ‚ÄúRecule‚Äù</strong></p>
        <p>√âtat : <strong id="voiceState">d√©sactiv√©e</strong></p>
        <p>Derni√®re phrase : <em id="lastTranscript">‚Äî</em></p>
      </div>
      <div>
        <button id="startVoice">‚ñ∂Ô∏è D√©marrer</button>
        <button id="stopVoice">‚èπÔ∏è Arr√™ter</button>
      </div>
    </aside>
  </main>

  <footer><small>Projet BUT3 R506 ‚Äì three.js + Web Speech API</small></footer>

  <script type="module" src="./js/main.js"></script>
</body>
</html>



MAIN.JS

import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import "./voice.js";

// === CONFIGURATION ===
const SCALE_DISTANCE = 0.00001;
const SCALE_SIZE = 0.00005;

// === DONN√âES ASTRONOMIQUES ===
const solarSystemData = {
  sun: {
    name: 'Soleil',
    radius: 696340,
    distance: 0,
    orbitalPeriod: 0,
    rotationPeriod: 25.05,
    color: 0xFDB813,
    modelPath: './ressources/3dmodels/sun/'
  },
  mercure: {
    name: 'Mercure',
    radius: 2439.7,
    distance: 57909050,
    orbitalPeriod: 87.97,
    rotationPeriod: 58.65,
    color: 0x8C7853,
    modelPath: './ressources/3dmodels/mercure/'
  },
  venus: {
    name: 'V√©nus',
    radius: 6051.8,
    distance: 108208000,
    orbitalPeriod: 224.7,
    rotationPeriod: -243,
    color: 0xFFC649,
    modelPath: './ressources/3dmodels/venus/'
  },
  earth: {
    name: 'Terre',
    radius: 6371,
    distance: 149598023,
    orbitalPeriod: 365.26,
    rotationPeriod: 1,
    color: 0x4169E1,
    modelPath: './ressources/3dmodels/earth/'
  },
  mars: {
    name: 'Mars',
    radius: 3389.5,
    distance: 227939200,
    orbitalPeriod: 686.98,
    rotationPeriod: 1.03,
    color: 0xCD5C5C,
    modelPath: './ressources/3dmodels/mars/'
  },
  jupiter: {
    name: 'Jupiter',
    radius: 69911,
    distance: 778570000,
    orbitalPeriod: 4332.59,
    rotationPeriod: 0.41,
    color: 0xDAA520,
    modelPath: './ressources/3dmodels/jupiter/'
  },
  saturne: {
    name: 'Saturne',
    radius: 58232,
    distance: 1433530000,
    orbitalPeriod: 10759.22,
    rotationPeriod: 0.45,
    color: 0xF4A460,
    modelPath: './ressources/3dmodels/saturne/'
  },
  uranus: {
    name: 'Uranus',
    radius: 25362,
    distance: 2872460000,
    orbitalPeriod: 30688.5,
    rotationPeriod: -0.72,
    color: 0x4FD0E4,
    modelPath: './ressources/3dmodels/uranus/'
  },
  neptune: {
    name: 'Neptune',
    radius: 24622,
    distance: 4495060000,
    orbitalPeriod: 60182,
    rotationPeriod: 0.67,
    color: 0x4169E1,
    modelPath: './ressources/3dmodels/neptune/'
  }
};

// === RENDU ===
const canvas = document.getElementById("three-canvas");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth * 0.75, window.innerHeight - 100);
renderer.setPixelRatio(window.devicePixelRatio);

// === SC√àNE ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// === CAM√âRA ===
const camera = new THREE.PerspectiveCamera(
  60,
  (window.innerWidth * 0.75) / (window.innerHeight - 100),
  0.1,
  20000
);
scene.add(camera);

// === LUMI√àRES ===
scene.add(new THREE.AmbientLight(0x666666));
const sunLight = new THREE.PointLight(0xffffff, 4, 0);
sunLight.position.set(0, 0, 0);
scene.add(sunLight);

// === CIEL √âTOIL√â ===
const starCount = 3000;
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(starCount * 3);
for (let i = 0; i < starCount * 3; i++)
  starPos[i] = (Math.random() - 0.5) * 10000;
starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 8 })));

// === PLAN√àTES ===
const loader = new GLTFLoader();
const planets = {};
let simDays = 0;
const timeScale = 1;

// Variables pour la cam√©ra
let targetPlanet = null;
let targetPosition = new THREE.Vector3(0, 0, 0);
let cameraDistance = 5000;
const defaultCameraDistance = 5000;

// Fonction pour cr√©er une sph√®re de fallback
function createFallbackSphere(data, scaledRadius) {
  const geometry = new THREE.SphereGeometry(scaledRadius, 32, 32);
  const material = new THREE.MeshPhongMaterial({ 
    color: data.color,
    emissive: data.name === 'Soleil' ? data.color : 0x000000,
    emissiveIntensity: data.name === 'Soleil' ? 0.8 : 0
  });
  return new THREE.Mesh(geometry, material);
}

// Charger les plan√®tes
Object.keys(solarSystemData).forEach((planetKey) => {
  const data = solarSystemData[planetKey];
  const scaledRadius = data.radius * SCALE_SIZE;
  const scaledDistance = data.distance * SCALE_DISTANCE;
  
  const planetGroup = new THREE.Group();
  scene.add(planetGroup);
  
  // Cr√©er l'orbite
  if (scaledDistance > 0) {
    const orbitGeometry = new THREE.BufferGeometry();
    const orbitPoints = [];
    const segments = 128;
    for (let i = 0; i <= segments; i++) {
      const theta = (i / segments) * Math.PI * 2;
      orbitPoints.push(
        Math.cos(theta) * scaledDistance,
        0,
        Math.sin(theta) * scaledDistance
      );
    }
    orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
    const orbitMaterial = new THREE.LineBasicMaterial({ 
      color: 0xFFFFFF, 
      opacity: 0.3, 
      transparent: true 
    });
    const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
    scene.add(orbit);
  }
  
  // Cr√©er un mesh temporaire (fallback)
  const fallbackMesh = createFallbackSphere(data, scaledRadius);
  fallbackMesh.position.x = scaledDistance;
  planetGroup.add(fallbackMesh);
  
  // Stocker les informations
  planets[planetKey] = {
    group: planetGroup,
    mesh: fallbackMesh,
    data: data,
    angle: Math.random() * Math.PI * 2,
    scaledDistance: scaledDistance,
    scaledRadius: scaledRadius,
    modelLoaded: false
  };
  
  // Charger le mod√®le GLTF
  loader.load(
    `${data.modelPath}scene.gltf`,
    (gltf) => {
      console.log(`‚úì Mod√®le charg√©: ${planetKey}`);
      const model = gltf.scene;
      
      // Centrer le mod√®le
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);
      
      // √âchelle
      model.scale.set(scaledRadius * 2, scaledRadius * 2, scaledRadius * 2);
      
      // Mat√©riaux
      model.traverse((node) => {
        if (node.isMesh) {
          if (planetKey === 'sun') {
            node.material = new THREE.MeshStandardMaterial({
              emissive: data.color,
              emissiveIntensity: 0.8,
              color: data.color,
            });
          } else {
            if (!node.material || !node.material.color) {
              node.material = new THREE.MeshStandardMaterial({
                color: data.color,
                roughness: 0.6,
                metalness: 0.1,
              });
            }
          }
        }
      });
      
      // Remplacer le fallback par le mod√®le
      planetGroup.remove(fallbackMesh);
      fallbackMesh.geometry.dispose();
      fallbackMesh.material.dispose();
      
      planetGroup.add(model);
      planets[planetKey].mesh = model;
      planets[planetKey].modelLoaded = true;
    },
    undefined,
    (err) => {
      console.warn(`‚ö† Erreur chargement ${planetKey}, utilisation du fallback:`, err);
      // Le fallback est d√©j√† en place
    }
  );
});

// === FONCTIONS DE CONTR√îLE ===
function focusOn(id) {
  console.log(`Focus sur: ${id}`);
  
  if (id === "systeme") {
    targetPlanet = null;
    targetPosition.set(0, 0, 0);
    cameraDistance = defaultCameraDistance;
    return;
  }
  
  if (planets[id]) {
    targetPlanet = id;
    cameraDistance = Math.max(300, planets[id].scaledRadius * 10);
    console.log(`Distance cam√©ra: ${cameraDistance}`);
  } else {
    console.warn(`Plan√®te non trouv√©e: ${id}`);
  }
}

function zoomIn() {
  cameraDistance = Math.max(100, cameraDistance * 0.7);
  console.log(`Zoom in: ${cameraDistance}`);
}

function zoomOut() {
  cameraDistance = Math.min(10000, cameraDistance * 1.4);
  console.log(`Zoom out: ${cameraDistance}`);
}

// Exposer les fonctions pour voice.js
window._solar = { focusOn, zoomIn, zoomOut };

// === POSITION INITIALE CAM√âRA ===
camera.position.set(0, 2000, 5000);
camera.lookAt(0, 0, 0);

// === ANIMATION ===
let last = performance.now();

function animate(now) {
  requestAnimationFrame(animate);
  const dt = (now - last) / 1000;
  last = now;
  simDays += dt * timeScale;
  
  // Mise √† jour des plan√®tes
  Object.keys(planets).forEach((key) => {
    const planet = planets[key];
    const data = planet.data;
    
    if (data.distance > 0) {
      const angularVelocity = (2 * Math.PI) / data.orbitalPeriod;
      planet.angle += angularVelocity * dt * timeScale;
      
      planet.group.position.x = Math.cos(planet.angle) * planet.scaledDistance;
      planet.group.position.z = Math.sin(planet.angle) * planet.scaledDistance;
    }
    
    // Rotation propre
    const rotationSpeed = (2 * Math.PI) / Math.abs(data.rotationPeriod);
    planet.mesh.rotation.y += rotationSpeed * dt * timeScale * Math.sign(data.rotationPeriod);
  });
  
  // Mise √† jour de la cam√©ra
  if (targetPlanet && planets[targetPlanet]) {
    const planet = planets[targetPlanet];
    targetPosition = planet.group.position.clone();
  }
  
  const desiredPos = new THREE.Vector3(
    targetPosition.x,
    cameraDistance * 0.4,
    targetPosition.z + cameraDistance
  );
  
  camera.position.lerp(desiredPos, 0.05);
  camera.lookAt(targetPosition);
  
  renderer.render(scene, camera);
}

animate();

// === RESIZE ===
window.addEventListener("resize", () => {
  camera.aspect = (window.innerWidth * 0.75) / (window.innerHeight - 100);
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth * 0.75, window.innerHeight - 100);
});

VOICE.JS

window.addEventListener("DOMContentLoaded", () => {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const stateEl = document.getElementById("voiceState");
  const transcriptEl = document.getElementById("lastTranscript");
  const btnStart = document.getElementById("startVoice");
  const btnStop = document.getElementById("stopVoice");

  if (!SpeechRecognition) {
    stateEl.textContent = "non support√©e ‚ùå";
    btnStart.disabled = true;
    btnStop.disabled = true;
    return;
  }

  const recognition = new SpeechRecognition();
  recognition.lang = "fr-FR";
  recognition.continuous = true;
  recognition.interimResults = false;

  let isRunning = false;

  // Mapping des commandes vocales
  const commands = {
    soleil: "sun",
    mercure: "mercure",
    v√©nus: "venus",
    venus: "venus",
    terre: "earth",
    mars: "mars",
    jupiter: "jupiter",
    saturne: "saturne",
    uranus: "uranus",
    neptune: "neptune",
    syst√®me: "systeme",
    systeme: "systeme",
    avance: "zoom_in",
    zoom: "zoom_in",
    d√©zoome: "zoom_out",
    recule: "zoom_out"
  };

  function handleCommand(cmd) {
    console.log(`Traitement commande: ${cmd}`);
    
    if (!window._solar) {
      console.error("window._solar n'est pas disponible");
      return;
    }
    
    const { focusOn, zoomIn, zoomOut } = window._solar;
    
    // Focus sur plan√®te ou syst√®me
    if (["sun", "mercure", "venus", "earth", "mars", "jupiter", "saturne", "uranus", "neptune", "systeme"].includes(cmd)) {
      focusOn(cmd);
    }
    // Zoom
    else if (cmd === "zoom_in") {
      zoomIn();
    }
    else if (cmd === "zoom_out") {
      zoomOut();
    }
  }

  recognition.onresult = (event) => {
    const text = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
    transcriptEl.textContent = text;
    console.log(`Transcription: "${text}"`);
    
    // Chercher une correspondance dans les commandes
    for (const [keyword, cmd] of Object.entries(commands)) {
      if (text.includes(keyword)) {
        console.log(`‚úì Commande reconnue: ${keyword} -> ${cmd}`);
        handleCommand(cmd);
        break;
      }
    }
  };

  recognition.onstart = () => {
    isRunning = true;
    stateEl.textContent = "üé§ active";
    stateEl.style.color = "#4f4";
    console.log("Reconnaissance vocale d√©marr√©e");
  };

  recognition.onend = () => {
    console.log("Reconnaissance vocale termin√©e");
    if (isRunning) {
      stateEl.textContent = "reconnexion‚Ä¶";
      setTimeout(() => {
        if (isRunning) {
          try {
            recognition.start();
          } catch (e) {
            console.warn("Impossible de red√©marrer:", e);
          }
        }
      }, 500);
    } else {
      stateEl.textContent = "d√©sactiv√©e";
      stateEl.style.color = "#f44";
    }
  };

  recognition.onerror = (event) => {
    console.error("Erreur reconnaissance vocale:", event.error);
    
    // Ne pas tenter de red√©marrer si l'erreur est "no-speech"
    if (event.error === "no-speech") {
      // C'est normal, on continue
      return;
    }
    
    if (event.error === "aborted") {
      console.log("Reconnaissance interrompue volontairement");
      return;
    }
    
    stateEl.textContent = `erreur: ${event.error}`;
  };

  btnStart.onclick = () => {
    if (!isRunning) {
      isRunning = true;
      try {
        recognition.start();
        console.log("D√©marrage manuel de la reconnaissance");
      } catch (e) {
        console.error("Erreur au d√©marrage:", e);
        isRunning = false;
      }
    }
  };

  btnStop.onclick = () => {
    isRunning = false;
    try {
      recognition.stop();
      console.log("Arr√™t manuel de la reconnaissance");
    } catch (e) {
      console.error("Erreur √† l'arr√™t:", e);
    }
    stateEl.textContent = "d√©sactiv√©e";
    stateEl.style.color = "#f44";
  };

  // Activation automatique au chargement
  setTimeout(() => {
    if (!isRunning) {
      btnStart.click();
    }
  }, 1000);
});